#!/usr/bin/env python

"""
This is a collection of standalone functions to make 2D contour plots
Most Functions are copied from some HistFitter macros
The data structure used everywhere is the json harvestlist
The json lists can be generated by the makelistfiles.py macro in HistFitter
See the "__main__" part for an example
"""

import math

import ROOT

from AtlasStyle import * 
SetAtlasStyle()
ROOT.gStyle.SetOptTitle(0)
ROOT.gStyle.SetOptStat(0)

def SetBorders( hist, val=0 ):
    "Copied from histfitter scripts - sets border values for 2d hist"
    numx = hist.GetNbinsX()
    numy = hist.GetNbinsY()

    for i in range(numx+2):
        hist.SetBinContent(i,0,val);
        hist.SetBinContent(i,numy+1,val);
    for i in range(numy+2):
        hist.SetBinContent(0,i,val);
        hist.SetBinContent(numx+1,i,val);

def AddBorders( hist, name='StupidName', title='StupidTitle'):
    "Copied from histfitter scripts - adds border bins"
    nbinsx = hist.GetNbinsX()
    nbinsy = hist.GetNbinsY()

    xbinwidth = ( hist.GetXaxis().GetBinCenter(nbinsx) - hist.GetXaxis().GetBinCenter(1) ) / float(nbinsx-1)
    ybinwidth = ( hist.GetYaxis().GetBinCenter(nbinsy) - hist.GetYaxis().GetBinCenter(1) ) / float(nbinsy-1)

    xmin = hist.GetXaxis().GetBinCenter(0) - xbinwidth/2.
    xmax = hist.GetXaxis().GetBinCenter(nbinsx+1) + xbinwidth/2.
    ymin = hist.GetYaxis().GetBinCenter(0) - ybinwidth/2.
    ymax = hist.GetYaxis().GetBinCenter(nbinsy+1) + ybinwidth/2.

    hist2 = ROOT.TH2F(name, title, nbinsx+2, xmin, xmax, nbinsy+2, ymin, ymax);

    for ibin1 in range(hist.GetNbinsX()+2):
        for ibin2 in range(hist.GetNbinsY()+2):
            hist2.SetBinContent( ibin1+1, ibin2+1, hist.GetBinContent(ibin1,ibin2) );

    return hist2

def MirrorBorders( hist ):
    "Copied from histfitter scripts - mirrors the border bins into the overflow bins"
    numx = hist.GetNbinsX()
    numy = hist.GetNbinsY()

    # corner points
    hist.SetBinContent(0,0,hist.GetBinContent(1,1))
    hist.SetBinContent(numx+1,numy+1,hist.GetBinContent(numx,numy))
    hist.SetBinContent(numx+1,0,hist.GetBinContent(numx,1))
    hist.SetBinContent(0,numy+1,hist.GetBinContent(1,numy))

    # Fix the other points
    for i in range(1,numx+1):
        hist.SetBinContent(i, 0, hist.GetBinContent(i,1));
        hist.SetBinContent(i, numy+1, hist.GetBinContent(i,numy));
    for i in range(1,numy+1):
        hist.SetBinContent(0,i, hist.GetBinContent(1,i));
        hist.SetBinContent(numx+1,i, hist.GetBinContent(numx,i));

def FixAndSetBorders(hist, name='hist3', title='hist3', val=0 ):
    """
    Copied from histfitter scripts
    - i don't fully get what it does (other than adding border bins with 0 content)
    - apparently the outcoming histogram gives nice closed contours
    """
    hist0 = hist.Clone() # histogram we can modify

    # mirror values of border bins into overflow bins
    MirrorBorders( hist0 )

    # add new border of bins around original histogram,
    # ... so 'overflow' bins become normal bins
    hist1 = AddBorders( hist0, "hist1", "hist1" )

    # set overflow bins to value
    SetBorders( hist1, val )

    # add new border of bins around original histogram,
    # ... so 'overflow' bins become normal bins
    histX = AddBorders( hist1, "histX", "histX" )

    hist3 = histX.Clone()
    hist3.SetName( name )
    hist3.SetTitle( title )

    del hist0, hist1, histX
    return hist3 # this can be used for filled contour histograms

def getContours(hist, level):
    "return all contours (TGraphs) of hist at the given level"
    h = hist.Clone()
    h.SetContour(1)
    h.SetContourLevel(0, level)
    h.Draw("CONT LIST")
    h.SetDirectory(0)
    ROOT.gPad.Update()
    contours = ROOT.gROOT.GetListOfSpecials().FindObject("contours")
    return [i.Clone() for i in contours[0]]

def getContoursFromHarvest(harvest, zkey, xkey, ykey, siglevel, **kwargs):
    smooth = triwsmooth(harvest, zkey, xkey, ykey, **kwargs)
    hist = FixAndSetBorders(smooth, getRandomHistName(), "contourhist")
    return getContours(hist, siglevel)

def myOneSigmaBand(gr1, gr2):
    """
    make a 1 sigma band graph from up and down contours
    This is much simplified to the procedure in the histfitter scripts
    Not sure if it works in all cases
    """
    gr = ROOT.TGraph()
    x = ROOT.Double()
    y = ROOT.Double()
    for i in range(gr1.GetN()):
        gr1.GetPoint(i, x, y)
        gr.SetPoint(gr.GetN(), x, y)
    for i in range(gr2.GetN()):
        gr2.GetPoint(i, x, y)
        gr.SetPoint(gr.GetN(), x, y)
    gr.SetFillColor(ROOT.TColor.GetColor("#ffd700"))
    return gr

def makeDummyOneSigmaGraph(lineGraph, bandGraph):
    """
    Make a dummy graph for usage in TLegend that is filled like the
    one sigma band and has the line color of the shown line.
    """
    dummygraph = ROOT.TGraph()
    dummygraph.SetLineColor(lineGraph.GetLineColor())
    dummygraph.SetLineStyle(lineGraph.GetLineStyle())
    dummygraph.SetLineWidth(lineGraph.GetLineWidth())
    dummygraph.SetFillColor(bandGraph.GetFillColor())
    dummygraph.SetFillStyle(bandGraph.GetFillStyle())
    return dummygraph


def normQuantileHack(p):
    _p = p
    if p < 3e-15: # NormQuantile will spit out 0 then ...
        #logger.warn("Too small p-value for ROOT.TMath.NormQuantile - will set it to 3e-15 (~7.8 sigma)")
        print "Too small p-value for ROOT.TMath.NormQuantile - will set it to 3e-15 (~7.8 sigma)"
        _p = 3e-15
    return ROOT.TMath.NormQuantile(1-_p)

def triwsmooth(harvest, zkey, xkey, ykey, **kwargs):
    """
    Fill harvest list entries into a TGraph and call Draw()
    Returns the resulting histogram (after calling another TH1::Smooth)
    Before drawing the points are transformed - default: pvalue -> significance
    """

    transformation = kwargs.get("transformation", normQuantileHack)

    if not transformation:
        transformation = lambda x:x

    smooth = kwargs.get("smooth", True)
    npx = kwargs.get("npx", None)
    npy = kwargs.get("npy", None)
    g = ROOT.TGraph2D()
    for line in harvest:
        z = float(line[zkey])
        if math.isnan(z):
            continue # not a number
        z = transformation(z)
        x = float(line[xkey])
        y = float(line[ykey])
        #logger.debug("Point: {}, {}, {}".format(x, y, z))
        print "Point: {}, {}, {}".format(x, y, z)
        g.SetPoint(g.GetN(), x, y, z)
    #logger.debug("All points done!")
    print "All points done!"
    if npx:
        g.SetNpx(npx)
    if npy:
        g.SetNpy(npy)
    #    g.Draw("TRIW old")
    #    g.Draw("TRIW")#
    #logger.debug("Creating histogram")
    print "Creating histogram"
    #hist = g.GetHistogram("old").Clone()
    hist = g.GetHistogram().Clone()
    #logger.debug("Got histogram!")
    print "Got histogram!"
    if smooth:
        hist.Smooth()
    hist.SetName(zkey)
    hist.SetDirectory(0)
    return hist

def getPointGraph(harvest, zkey, xkey, ykey, **kwargs):
    transformation = kwargs.get("transformation", normQuantileHack)

    if not transformation:
        transformation = lambda x:x

    smooth = kwargs.get("smooth", True)
    npx = kwargs.get("npx", None)
    npy = kwargs.get("npy", None)
    g = ROOT.TGraph2D()
    for line in harvest:
        z = float(line[zkey])
        if math.isnan(z):
            continue # not a number
        z = transformation(z)
        x = float(line[xkey])
        y = float(line[ykey])
        g.SetPoint(g.GetN(), x, y, z)
    if npx:
        g.SetNpx(npx)
    if npy:
        g.SetNpy(npy)
    return g

def drawNumbers(harvest, zkey, xkey, ykey, **kwargs):
    "Draw p values and significances for each point for debugging"
    transformation = kwargs.get("transformation", normQuantileHack)
    printString = kwargs.get("printString", False)
    numbers = []
    dots = []
    drawAxis = kwargs.get("drawAxis", False)
    drawOnlyAxis = kwargs.get("drawOnlyAxis", False)
    if drawAxis:
        xmin = min([d[xkey] for d in harvest])
        xmax = max([d[xkey] for d in harvest])
        ymin = min([d[ykey] for d in harvest])
        ymax = max([d[ykey] for d in harvest])
        dx = xmax-xmin
        dy = ymax-ymin
        axisHist = ROOT.TH2F(getRandomHistName(), "", 100, xmin-0.1*dx, xmax+0.1*dx, 100, ymin-0.1*dy, ymax+0.1*dy)
        axisHist.Draw()
        dots.append(axisHist)
    for line in harvest:
        if drawOnlyAxis:
            break
        number = ROOT.TLatex()
        dot = ROOT.TGraph()
        if not printString:
            z = float(line.get(zkey, 1))
        else:
            z = line.get(zkey, 1)
        x = float(line[xkey])
        y = float(line[ykey])
        if transformation:
            labeltext = "#splitline{%.3e}{(%.2f#sigma)}" % (z, transformation(z))
        elif not printString:
            labeltext = "  %.3f" % z
        else:
            labeltext = z
        #logger.debug("Drawing label with text: {}".format(labeltext))
        print "Drawing label with text: {}".format(labeltext)
        number.SetTextFont(43)
        number.SetTextSize(10*kwargs.get("textScale", 1))
        number.SetTextAlign(12)
        if not kwargs.get("drawOnlyDots", False):
            number.DrawLatex(x, y, labeltext)
        dot.SetPoint(dot.GetN(), x, y)
        dot.SetMarkerColor(kwargs.get("markerColor", ROOT.kBlack))
        dot.SetMarkerStyle(20)
        dot.SetMarkerSize(kwargs.get("markerSize", 0.5))
        dot.Draw("p same")
        numbers.append(number)
        dots.append(dot)
    return numbers, dots


def getSignalPoints(regex, *paths):
    """Returns a dictionary of matching group dicts (and rootfile paths
    where they were found) corresponding to the signal tree names that
    were found. For example:
    regex = "GG2stepWZ_(?P<mg>.*?)_(?P<mch>.*?)_(?P<mn2>.*?)_(?P<mn>.*?)_NoSys"
    will return a dict like:
    {
      "GG2stepWZ_1200_1100_1000_900_NoSys" : {"paths" : {"path1", "path2", ...}, "mg" : "1200", "mch" : "1100", "mn2" : "1000", "mn" : 900},
      ...
    }
    """
    import re
    sigpoints = {}
    regex = re.compile(regex)
    for path in paths:
        rf = ROOT.TFile.Open(path)
        for k in rf.GetListOfKeys():
            match = regex.match(k.GetName())
            pathlist = set()
            if not match:
                continue
            if k.GetName() in sigpoints:
                pathlist = sigpoints[k.GetName()]["paths"]
                if path in pathlist:
                    #logger.warning("Found multiple cycles for key {}".format(k.GetName()))
                    print "Found multiple cycles for key {}".format(k.GetName())
            pathlist.add(path)
            sigpoints[k.GetName()] = dict(match.groupdict(), paths=pathlist)
    return sigpoints

def getRandomHistName():
    return "hist_{}".format(random.randrange(0, 1e6))



if __name__ == "__main__":

    ROOT.gROOT.SetBatch()

    exampleHarvest = [
        # {{{
        {"CLsexp": 4.353894e-08, "clsd1s": 2.970995e-10, "clsu1s": 4.522759e-06, "mg": 1000.0, "mn": 100.0},
        {"CLsexp": 8.980757e-07, "clsd1s": 1.060292e-08, "clsu1s": 5.422916e-05, "mg": 1000.0, "mn": 300.0},
        {"CLsexp": 0.03017863, "clsd1s": 0.004841628, "clsu1s": 0.1443597, "mg": 1000.0, "mn": 500.0},
        {"CLsexp": 0.5150741, "clsd1s": 0.3112009, "clsu1s": 0.756493, "mg": 1000.0, "mn": 600.0},
        {"CLsexp": 0.9849306, "clsd1s": 0.9714656, "clsu1s": 0.9945166, "mg": 1000.0, "mn": 700.0},
        {"CLsexp": 0.9928526, "clsd1s": 0.9863989, "clsu1s": 0.9974121, "mg": 1000.0, "mn": 800.0},
        {"CLsexp": 4.705227e-05, "clsd1s": 1.254989e-06, "clsu1s": 0.001272949, "mg": 1100.0, "mn": 400.0},
        {"CLsexp": 0.001388201, "clsd1s": 8.520449e-05, "clsu1s": 0.01664823, "mg": 1100.0, "mn": 500.0},
        {"CLsexp": 0.5682141, "clsd1s": 0.3663797, "clsu1s": 0.7917723, "mg": 1100.0, "mn": 600.0},
        {"CLsexp": 0.4134072, "clsd1s": 0.2176969, "clsu1s": 0.6801528, "mg": 1100.0, "mn": 700.0},
        {"CLsexp": 0.9815644, "clsd1s": 0.9651648, "clsu1s": 0.9932775, "mg": 1100.0, "mn": 800.0},
        {"CLsexp": 0.7016212, "clsd1s": 0.5251138, "clsu1s": 0.8692499, "mg": 1200.0, "mn": 800.0},
        {"CLsexp": 1.180193e-08, "clsd1s": 6.454095e-11, "clsu1s": 1.526817e-06, "mg": 1200.0, "mn": 100.0},
        {"CLsexp": 1.141418e-06, "clsd1s": 1.410794e-08, "clsu1s": 6.587157e-05, "mg": 1200.0, "mn": 300.0},
        {"CLsexp": 0.0001392276, "clsd1s": 4.767594e-06, "clsu1s": 0.002948429, "mg": 1200.0, "mn": 400.0},
        {"CLsexp": 4.546394e-05, "clsd1s": 1.203337e-06, "clsu1s": 0.001239297, "mg": 1200.0, "mn": 500.0},
        {"CLsexp": 0.004528425, "clsd1s": 0.0003896487, "clsu1s": 0.03919045, "mg": 1200.0, "mn": 600.0},
        {"CLsexp": 0.09198642, "clsd1s": 0.02285691, "clsu1s": 0.2931835, "mg": 1200.0, "mn": 700.0},
        {"CLsexp": 0.1129462, "clsd1s": 0.03068098, "clsu1s": 0.3319021, "mg": 1300.0, "mn": 700.0},
        {"CLsexp": 0.2823834, "clsd1s": 0.1197198, "clsu1s": 0.5587663, "mg": 1300.0, "mn": 800.0},
        {"CLsexp": 1.189113e-05, "clsd1s": 2.352968e-07, "clsu1s": 0.0004314413, "mg": 1300.0, "mn": 100.0},
        {"CLsexp": 2.147245e-05, "clsd1s": 4.81941e-07, "clsu1s": 0.000688246, "mg": 1300.0, "mn": 200.0},
        {"CLsexp": 1.117557e-05, "clsd1s": 2.182716e-07, "clsu1s": 0.0004107193, "mg": 1300.0, "mn": 300.0},
        {"CLsexp": 5.241928e-05, "clsd1s": 1.432486e-06, "clsu1s": 0.001384767, "mg": 1300.0, "mn": 400.0},
        {"CLsexp": 0.0007886549, "clsd1s": 4.160286e-05, "clsu1s": 0.01095618, "mg": 1300.0, "mn": 500.0},
        {"CLsexp": 0.005059822, "clsd1s": 0.0004501544, "clsu1s": 0.04240637, "mg": 1300.0, "mn": 600.0},
        {"CLsexp": 0.009268721, "clsd1s": 0.0009952473, "clsu1s": 0.06487233, "mg": 1400.0, "mn": 600.0},
        {"CLsexp": 0.05359963, "clsd1s": 0.01068035, "clsu1s": 0.2093916, "mg": 1400.0, "mn": 700.0},
        {"CLsexp": 0.1714552, "clsd1s": 0.05643257, "clsu1s": 0.4238537, "mg": 1400.0, "mn": 800.0},
        {"CLsexp": 9.468766e-05, "clsd1s": 2.962158e-06, "clsu1s": 0.002190805, "mg": 1400.0, "mn": 100.0},
        {"CLsexp": 3.570032e-05, "clsd1s": 8.954436e-07, "clsu1s": 0.001025917, "mg": 1400.0, "mn": 200.0},
        {"CLsexp": 0.0001278869, "clsd1s": 4.292187e-06, "clsu1s": 0.002762029, "mg": 1400.0, "mn": 300.0},
        {"CLsexp": 0.002655014, "clsd1s": 0.0001953721, "clsu1s": 0.02671516, "mg": 1400.0, "mn": 400.0},
        {"CLsexp": 0.002304162, "clsd1s": 0.0001628388, "clsu1s": 0.02410779, "mg": 1400.0, "mn": 500.0},
        {"CLsexp": 0.006418154, "clsd1s": 0.000614031, "clsu1s": 0.05016757, "mg": 1500.0, "mn": 500.0},
        {"CLsexp": 0.04201369, "clsd1s": 0.007621154, "clsu1s": 0.1791323, "mg": 1500.0, "mn": 600.0},
        {"CLsexp": 0.07314844, "clsd1s": 0.01651348, "clsu1s": 0.2546025, "mg": 1500.0, "mn": 700.0},
        {"CLsexp": 0.00400214, "clsd1s": 0.0003319201, "clsu1s": 0.03588429, "mg": 1500.0, "mn": 100.0},
        {"CLsexp": 0.005622386, "clsd1s": 0.0005164806, "clsu1s": 0.04569427, "mg": 1500.0, "mn": 200.0},
        {"CLsexp": 0.004573572, "clsd1s": 0.0003947049, "clsu1s": 0.03946821, "mg": 1500.0, "mn": 300.0},
        {"CLsexp": 0.004684751, "clsd1s": 0.0004072238, "clsu1s": 0.0401485, "mg": 1500.0, "mn": 400.0},
        {"CLsexp": 0.02015043, "clsd1s": 0.002801177, "clsu1s": 0.1103338, "mg": 1600.0, "mn": 400.0},
        {"CLsexp": 0.06544986, "clsd1s": 0.01412092, "clsu1s": 0.2375311, "mg": 1600.0, "mn": 500.0},
        {"CLsexp": 0.07034667, "clsd1s": 0.01562886, "clsu1s": 0.2484884, "mg": 1600.0, "mn": 600.0},
        {"CLsexp": 0.03350922, "clsd1s": 0.005585843, "clsu1s": 0.1546309, "mg": 1600.0, "mn": 100.0},
        {"CLsexp": 0.04009356, "clsd1s": 0.007145345, "clsu1s": 0.1737933, "mg": 1600.0, "mn": 200.0},
        {"CLsexp": 0.03282238, "clsd1s": 0.005429836, "clsu1s": 0.1525474, "mg": 1600.0, "mn": 300.0},
        {"CLsexp": 0.1055402, "clsd1s": 0.02782751, "clsu1s": 0.318657, "mg": 1700.0, "mn": 300.0},
        {"CLsexp": 0.1077652, "clsd1s": 0.02867475, "clsu1s": 0.3226832, "mg": 1700.0, "mn": 400.0},
        {"CLsexp": 0.1462129, "clsd1s": 0.04464236, "clsu1s": 0.3865957, "mg": 1700.0, "mn": 500.0},
        {"CLsexp": 0.137618, "clsd1s": 0.04086007, "clsu1s": 0.3731377, "mg": 1700.0, "mn": 100.0},
        {"CLsexp": 0.111305, "clsd1s": 0.03004042, "clsu1s": 0.3290049, "mg": 1700.0, "mn": 200.0},
        {"CLsexp": 0.8678336, "clsd1s": 0.7672244, "clsu1s": 0.948177, "mg": 600.0, "mn": 100.0},
        {"CLsexp": 0.9474435, "clsd1s": 0.9027779, "clsu1s": 0.9804177, "mg": 600.0, "mn": 300.0},
        {"CLsexp": 0.9870399, "clsd1s": 0.9754272, "clsu1s": 0.9952903, "mg": 600.0, "mn": 400.0},
        {"CLsexp": 0.9976635, "clsd1s": 0.9955404, "clsu1s": 0.9991565, "mg": 600.0, "mn": 500.0},
        {"CLsexp": 0.001936636, "clsd1s": 0.0001303269, "clsu1s": 0.02124461, "mg": 800.0, "mn": 100.0},
        {"CLsexp": 0.8665131, "clsd1s": 0.7650891, "clsu1s": 0.9476144, "mg": 800.0, "mn": 300.0},
        {"CLsexp": 0.9289271, "clsd1s": 0.8700247, "clsu1s": 0.9732051, "mg": 800.0, "mn": 400.0},
        {"CLsexp": 0.9679028, "clsd1s": 0.9398648, "clsu1s": 0.9881946, "mg": 800.0, "mn": 500.0},
        {"CLsexp": 0.4273316, "clsd1s": 0.2295875, "clsu1s": 0.6913883, "mg": 800.0, "mn": 600.0},
        {"CLsexp": 0.999709, "clsd1s": 0.9994437, "clsu1s": 0.999895, "mg": 800.0, "mn": 700.0},
        {"CLsexp": 0.6652005, "clsd1s": 0.4788083, "clsu1s": 0.8495088, "mg": 900.0, "mn": 600.0},
        {"CLsexp": 0.996531, "clsd1s": 0.9933835, "clsu1s": 0.9987469, "mg": 900.0, "mn": 700.0},
        # }}}
    ]

    xs = []
    ys = []
    zs = []
    for pointDict in exampleHarvest:
        xs.append(pointDict["mg"])
        ys.append(pointDict["mn"])
        zs.append(ROOT.TMath.NormQuantile(1-pointDict["CLsexp"]))

    print("X"*50)
    print(len(xs))
    for x in xs:
        print("{:.5f},".format(x))
    print("Y"*50)
    print(len(ys))
    for y in ys:
        print("{:.5f},".format(y))
    print("Z"*50)
    print(len(zs))
    for z in zs:
        print("{:.5f},".format(z))

    # make an example contour plot
    #atlasStyle.setAtlasStyle(th2=True, reset=True)
    level = ROOT.TMath.NormQuantile(0.95) # draw 95% cls contour
    transformation = lambda p: ROOT.TMath.NormQuantile(1-p) # transform to significances for drawing
    x = "mg"
    y = "mn"
    smooth = True
    npx = None
    npy = None
    # ROOT.gStyle.SetNumberContours(100)
    # npx = 500
    # npy = 500
    clsexp = triwsmooth(exampleHarvest, "CLsexp", x, y, transformation=transformation, smooth=smooth, npx=npx, npy=npy)
    clsexp_up = triwsmooth(exampleHarvest, "clsu1s", x, y, transformation=transformation, smooth=smooth, npx=npx, npy=npy)
    clsexp_down = triwsmooth(exampleHarvest, "clsd1s", x, y, transformation=transformation, smooth=smooth, npx=npx, npy=npy)
    fixedhist = FixAndSetBorders(clsexp, "cls", "cls")
    fixedhist_up = FixAndSetBorders(clsexp_up, "cls_up", "cls_up")
    fixedhist_down = FixAndSetBorders(clsexp_down, "cls_down", "cls_down")
    contours = getContours(fixedhist, level)
    contours_up = getContours(fixedhist_up, level)
    contours_down = getContours(fixedhist_down, level)
    errorband = myOneSigmaBand(contours_up[0], contours_down[0])
    c = ROOT.TCanvas()
    numbers = drawNumbers(exampleHarvest, "CLsexp", x, y)
    fixedhist.Draw("colz")
    errorband.SetFillStyle(3354)
    errorband.SetFillColor(ROOT.kBlack)
    errorband.Draw("f same")
    for contour in contours_up + contours_down:
        contour.SetLineColor(ROOT.kBlack)
        contour.SetLineStyle(7)
        contour.Draw("l same")
    for contour in contours:
        contour.SetLineStyle(1)
        contour.SetLineColor(ROOT.kBlack)
        contour.Draw("l same")
    numbers = drawNumbers(exampleHarvest, "CLsexp", x, y)
    # g = getPointGraph(exampleHarvest, "CLsexp", x, y, transformation=transformation, smooth=smooth, npx=npx, npy=npy)
    # g.Draw("tri")
    c.SaveAs("example_contour.pdf")
    #c.SaveAs("example_contour.C")

    # g = getPointGraph(exampleHarvest, "CLsexp", x, y, transformation=transformation, smooth=smooth, npx=npx, npy=npy)
    # c = ROOT.TCanvas("c2")
    # g.Draw("tri1")
    # c.SaveAs("tri1.pdf")
    # f = ROOT.TFile.Open("hans.root", "RECREATE")
    # g.Write("graph")
    # f.Write()
    # f.Close()
